pipeline {
  agent any

  environment {
  APP_NAME        = "sample-app"
          // These IDs must match exactly what you created in Jenkins Credentials Provider
  NEXUS_URL       = credentials('nexus-url')
  GCP_PROJECT     = credentials('gcp-project-id')
  GCR_REGION      = credentials('gcr-region')
  IMAGE_NAME      = "${GCR_REGION}/${GCP_PROJECT}/${APP_NAME}/${APP_NAME}"
  VERSION         = "1.0.${BUILD_NUMBER}"
  

  // IDs for Global Environment Variables (Set in Jenkins System Config)
  DEV_URL          = "${env.DEV_SERVER_IP}"
  TEST_URL         = "${env.TEST_SEVER_IP}"
  PROD_URL         = "${env.PROD_SERVER_IP}"

  // SSH User and Credential ID
  SSH_USER        = "raviakira9"       //user to login
  SSH_CRED_ID     = "my-ssh-key-id" 
}

stages {
  stage('Checkout') {
    steps {
      git branch: 'main', url: 'https://github.com/Ravikumar-code-maker/docker-pipeline'
    }
  }
  stage('Build & Test') {
    steps {
      dir('sample-app') {
        sh "mvn clean package -DskipTests" 
      }
    }
  }
//   stage('Publish to Nexus') {
//     steps {
//       dir('sample-app') {
//         withCredentials([usernamePassword(credentialsId: 'nexus-creds', 
//                          usernameVariable: 'USER', passwordVariable: 'PASS')]) {
//           sh '''
//             mvn deploy \
//             -DaltDeploymentRepository=nexus::default::${NEXUS_URL} \
//             -Dusername=${USER} \
//             -Dpassword=${PASS} \
//             -DskipTests
//           '''
//         }
//       }
//     }
// }
  stage('Publish to Nexus') {
    steps {
      dir('sample-app') {
        // This 'fileId' uses your managed settings file ID: 'nexus-global-settings'
        configFileProvider([configFile(fileId: 'nexus-global-settings', variable: 'MAVEN_SETTINGS')]) {
          sh '''
            # This uses the secure, pre-configured settings file
            mvn deploy \
            -s ${MAVEN_SETTINGS} \
            -DaltDeploymentRepository=nexus-releases::default::${NEXUS_URL} \
            -DskipTests
          '''
        }
      }
    }
}


  stage('Docker Build & PUSH') {
    steps {
      // CRITICAL: This moves the current working directory before running docker build
      dir('sample-app') { 
        withCredentials([file(credentialsId: 'gcr-sa-key', variable: 'GCP_KEY')]) {
          sh '''
          docker build -t ${IMAGE_NAME}:${VERSION} .
          gcloud auth activate-service-account --key-file=${GCP_KEY} 
          gcloud auth configure-docker us-central1-docker.pkg.dev -q
          docker push ${IMAGE_NAME}:${VERSION}
        '''
        }
      }
    }
  }
  

  // stage('Deploy to Dev') {
  //    steps {
  //        sh 
  //        docker stop ${APP_NAME}-dev || true
  //        docker rm ${APP_NAME}-dev || true
  //        docker run -d --name ${APP_NAME}-dev -p 8081:8080 ${IMAGE_NAME}:${VERSION}
         
  //    }
  // }
  stage('Deploy to Dev') {
    steps {
      //Pass URL, environment label, and port to the helper function
      deployToRemote(env.DEV_URL,'dev','8082')
    }
  }
  stage('Approval for Test') {
    steps {
      input message: "Promote to Test environment?"
    }
  }   
  stage('Deploy To Test'){
    steps {
      deployToRemote(env.TEST_URL,'test','8080')
    }
  }
  stage('Approval To Prod'){
    steps {
      input message: "Promote to PRODUCTION?" // CORRECT
    }
  }
  stage('Deploy To PRod') {
    steps {
      deployToRemote(env.PROD_URL, 'prod', '8080')
    }
  }                                                        
}
}

post {
  always {
    //cleans the jenkines workspace to save disk space 
    cleanWS()
    echo "Workspace cleaned successfully."
  }
  success {
    echo "Pipeline completed successfully! Version ${VERSION} is deployed."
  }
  failure {
    //Helpful for debugging: prints the last few lines of the log
    echo "Pipeline Failed.Check the logs above for errors."
  }
}

// DRY Function to handle remote SSH deployment
def deployToRemote(serverUrl, envName, port) {
    // Uses the SSH Agent Plugin to provide the private key securely
    sshagent([env.SSH_CRED_ID]) {
        sh """
        ssh -o StrictHostKeyChecking=no ${env.SSH_USER}@${serverUrl} << 'EOF'
             # 1. Authenticate Docker with Artifact Registry on the remote server
             # This ensures the remote server has permission to pull from GCP
             gcloud auth configure-docker us-central1-docker.pkg.dev -q

             # 2. Pull the image using the VERSION (e.g., 1.0.37) instead of just BUILD_NUMBER
             docker pull ${IMAGE_NAME}:${VERSION}

             # 3. Stop and Remove existing container if it exists
             docker stop ${APP_NAME}-${envName} || true
             docker rm ${APP_NAME}-${envName} || true

             # 4. Run the new container
             docker run -d --name ${APP_NAME}-${envName} -e ENV=${envName} -p ${port}:8080 ${IMAGE_NAME}:${VERSION}

             # 5. Optional: Clean up dangling images to save space
             docker image prune -f
EOF
        """
    }
}































