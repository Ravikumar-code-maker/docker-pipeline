pipeline {
  agent any

  environment {
  APP_NAME        = "sample-app"
          // These IDs must match exactly what you created in Jenkins Credentials Provider
  NEXUS_URL       = credentials('nexus-url')
  GCP_PROJECT     = credentilas('gcp-project-id')
  GCR_REGION      = credentials('gcr-region')
  IMAGE_ NAME     = "${GCR_REGION}/${GCP_PROJECT}/${APP_NAME}"
  VERSION         = "1.0.${BUILD_NUMBER}"

  // IDs for Global Environment Variables (Set in Jenkins System Config)
  DEV_URL          = "${env.DEV_SERVER_IP}"
  TEST_URL         = "${env.TEST_SEVER_IP}"
  PROD_URL         = "${env.PROD_SERVER_IP}"

  // SSH User and Credential ID
  SSH_USER        = "raviakira9"
  SSH_CRED_ID     = "my-ssh-key-id" 
}

stages {
  stage('Checkout') {
    steps {
      git branch: 'main', url: 'https://github.com/Ravikumar-code-maker/docker-pipeline'
    }
  }
  stage('Build & Test') {
    steps {
      dir('sample-app') {
        sh "mvn clean package -DskipTests" 
      }
    }
  }
  stage('Publsih to Nexus') {
    steps {
      withCredentials([usernamePassword(credentialsId: 'nexus-creds', usernameVariable: 'USER', passwordVariable: 'PASS')]) {
        sh ""
        mvn deploy \
        -Dnexus.NEXUS_REPO_URL=${NEXUS_URL} \
        -Dnexus.username=${USER} \
        -Dnexus.password=${PASS} \
        -Dnexus.version=${VERSION} \
      }
    }
  }
  stage('Docker Build & PUSH') {
    steps {
      withcredentials([file(credentialsId: 'gcr-sa-key', variable: 'GCP_KEY')]) {
        sh """
        docker build -t ${IMAGE_NAME}:${VERSION}
        gcloud auth activate-service-account --key-file=${GCP_KEY} 
        gcloud auth configure-docker -q
        docker push ${IMAGE_NAME}:${VERSION}
        """
      }
    }
  }
  // stage('Deploy to Dev') {
  //    steps {
  //        sh """
  //        docker stop ${APP_NAME}-dev || true
  //        docker rm ${APP_NAME}-dev || true
  //        docker run -d --name ${APP_NAME}-dev -p 8081:8080 ${IMAGE_NAME}:${VERSION}
         
  //    }
  // }
  stage('Deploy to Dev') {
    steps {
      //Pass URL, environment label, and port to the helper function
      deployToRemote(env.DEV_URL,'dev','8082')
    }
  }
  stage('Approval for Test') {
    steps {
      input message: "Promote to Test environment?"
    }
  }   
  stage('Deploy To Test'){
    steps {
      deployToRemote(env.TEST_URL,'test','8080')
    }
  }
  stage('Approval To Prod'){
    steps {
      input message: "Promote to PRODUCTION?" // CORRECT
    }
  }
  stage('Deploy To PRod') {
    steps {
      deployToRemote(env.PROD_URL, 'prod', '8080')
    }
  }                                                        
}
}

// DRY Function to handle remote SSH deployment
def deployToRemote(serverUrl, envName, port) {
    // Uses the SSH Agent Plugin to provide the private key securely
    sshagent([env.SSH_CRED_ID]) {
        sh """
        ssh -o StrictHostKeyChecking=no ${env.SSH_USER}@${serverUrl} << 'EOF'
                    # Commands executed on the remote server
             docker pull ${IMAGE_NAME}:${BUILD_NUMBER}
             docker stop ${APP_NAME}-${envName} || true
             docker rm ${APP_NAME}-${envName} || true
             docker run -d --name ${APP_NAME}-${envName} -e ENV=${envNAme} -p ${port}:8080 ${IMAGE_NAME}:${BUILD_NUMBER}
EOF
            """
    }
}








