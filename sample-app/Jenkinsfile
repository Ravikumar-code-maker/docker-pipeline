pipeline {
  agent any

  environment {
  APP_NAME        = "sample-app"
          // These IDs must match exactly what you created in Jenkins Credentials Provider
  NEXUS_URL       = credentials('nexus-url')
  GCP_PROJECT     = credentials('gcp-project-id')
  GCR_REGION      = credentials('gcr-region')
  IMAGE_NAME      = "${GCR_REGION}/${GCP_PROJECT}/${APP_NAME}"
  VERSION         = "1.0.${BUILD_NUMBER}"
  

  // IDs for Global Environment Variables (Set in Jenkins System Config)
  DEV_URL          = "${env.DEV_SERVER_IP}"
  TEST_URL         = "${env.TEST_SEVER_IP}"
  PROD_URL         = "${env.PROD_SERVER_IP}"

  // SSH User and Credential ID
  SSH_USER        = "raviakira9"       //user to login
  SSH_CRED_ID     = "my-ssh-key-id" 
}

stages {
  stage('Checkout') {
    steps {
      git branch: 'main', url: 'https://github.com/Ravikumar-code-maker/docker-pipeline'
    }
  }
  stage('Build & Test') {
    steps {
      dir('sample-app') {
        sh "mvn clean package -DskipTests" 
      }
    }
  }
//   stage('Publish to Nexus') {
//     steps {
//       dir('sample-app') {
//         withCredentials([usernamePassword(credentialsId: 'nexus-creds', 
//                          usernameVariable: 'USER', passwordVariable: 'PASS')]) {
//           sh """
//             mvn deploy \
//             -DaltDeploymentRepository=nexus::default::${NEXUS_URL} \
//             -Dusername=${USER} \
//             -Dpassword=${PASS} \
//             -DskipTests
//           """
//         }
//       }
//     }
// }
  stage('Publish to Nexus') {
    steps {
      dir('sample-app') {
      // 'nexus-global-settings' must be the ID you set in Managed Files
        configFileProvider([configFile(fileId: 'nexus-global-settings', variable: 'MAVEN_SETTINGS')]) {
          sh """
             mvn deploy \
             -s ${MAVEN_SETTINGS} \
             -DaltDeploymentRepositoy=nexus-releases::default::${NEXUS_URL} \
             -DskipTests
             """
        }
      }
    }
  }


  stage('Docker Build & PUSH') {
    steps {
      withCredentials([file(credentialsId: 'gcr-sa-key', variable: 'GCP_KEY')]) {
        sh """
        docker build -t ${IMAGE_NAME}:${VERSION}
        gcloud auth activate-service-account --key-file=${GCP_KEY} 
        gcloud auth configure-docker -q
        docker push ${IMAGE_NAME}:${VERSION}
        """
      }
    }
  }
  // stage('Deploy to Dev') {
  //    steps {
  //        sh """
  //        docker stop ${APP_NAME}-dev || true
  //        docker rm ${APP_NAME}-dev || true
  //        docker run -d --name ${APP_NAME}-dev -p 8081:8080 ${IMAGE_NAME}:${VERSION}
         
  //    }
  // }
  stage('Deploy to Dev') {
    steps {
      //Pass URL, environment label, and port to the helper function
      deployToRemote(env.DEV_URL,'dev','8082')
    }
  }
  stage('Approval for Test') {
    steps {
      input message: "Promote to Test environment?"
    }
  }   
  stage('Deploy To Test'){
    steps {
      deployToRemote(env.TEST_URL,'test','8080')
    }
  }
  stage('Approval To Prod'){
    steps {
      input message: "Promote to PRODUCTION?" // CORRECT
    }
  }
  stage('Deploy To PRod') {
    steps {
      deployToRemote(env.PROD_URL, 'prod', '8080')
    }
  }                                                        
}
}

post {
  always {
    //cleans the jenkines workspace to save disk space 
    cleanWS()
    echo "Workspace cleaned successfully."
  }
  success {
    echo "Pipeline completed successfully! Version ${VERSION} is deployed."
  }
  failure {
    //Helpful for debugging: prints the last few lines of the log
    echo "Pipeline Failed.Check the logs above for errors."
  }
}

// DRY Function to handle remote SSH deployment
def deployToRemote(serverUrl, envName, port) {
    // Uses the SSH Agent Plugin to provide the private key securely
    sshagent([env.SSH_CRED_ID]) {
        sh """
        ssh -o StrictHostKeyChecking=no ${env.SSH_USER}@${serverUrl} << 'EOF'
                    # Commands executed on the remote server
             docker pull ${IMAGE_NAME}:${BUILD_NUMBER}
             docker stop ${APP_NAME}-${envName} || true
             docker rm ${APP_NAME}-${envName} || true
             docker run -d --name ${APP_NAME}-${envName} -e ENV=${envName} -p ${port}:8080 ${IMAGE_NAME}:${BUILD_NUMBER}
EOF
            """
    }
}





















